namespace Demarbit.StrongIds.Generator.Templates;

internal static class StringTemplate
{
    public static string Generate(StrongIdModel model)
    {
        var accessibility = model.IsPublic ? "public" : "internal";

        return $$"""
                  // <auto-generated />
                  #nullable enable
                  
                  using System;
                  using System.ComponentModel;
                  using System.Text.Json;
                  using System.Text.Json.Serialization;
                  
                  namespace {{model.Namespace}};
                  
                  [JsonConverter(typeof({{model.Name}}JsonConverter))]
                  [TypeConverter(typeof({{model.Name}}TypeConverter))]
                  {{accessibility}} readonly partial struct {{model.Name}} 
                      : IEquatable<{{model.Name}}>, IComparable<{{model.Name}}>, IParsable<{{model.Name}}>
                  {
                      public string Value => _value ?? string.Empty;
                      private string _value;
                  
                      public {{model.Name}}(string value) => _value = value;
                  
                      public static {{model.Name}} From(string value) => !string.IsNullOrEmpty(value)
                        ? new(value)
                        : throw new ArgumentException("Value cannot be empty", nameof(value));
                      public static {{model.Name}} Empty => new("");
                  
                      // Equality
                      public bool Equals({{model.Name}} other) => Value.Equals(other.Value);
                      public override bool Equals(object? obj) => obj is {{model.Name}} other && Equals(other);
                      public override int GetHashCode() => Value.GetHashCode();
                      public static bool operator ==({{model.Name}} left, {{model.Name}} right) => left.Equals(right);
                      public static bool operator !=({{model.Name}} left, {{model.Name}} right) => !left.Equals(right);
                  
                      // Comparable
                      public int CompareTo({{model.Name}} other) => Value.CompareTo(other.Value);
                  
                      // Parse
                      public static {{model.Name}} Parse(string s, IFormatProvider? provider = null) 
                          => From(s);
                      public static bool TryParse(string? s, IFormatProvider? provider, out {{model.Name}} result)
                      {
                          if (!string.IsNullOrEmpty(s)) 
                          {
                                result = new(s);
                                return true;
                          }
                          result = default;
                          return false;
                      }
                  
                      public override string ToString() => Value;
                  
                      // Implicit/explicit conversions
                      public static explicit operator {{model.Name}}(string value) => new(value);
                      public static implicit operator string({{model.Name}} id) => id.Value;
                  
                      // JSON converter
                      {{accessibility}} sealed class {{model.Name}}JsonConverter : JsonConverter<{{model.Name}}>
                      {
                          public override {{model.Name}} Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                              => new(reader.GetString());
                          public override void Write(Utf8JsonWriter writer, {{model.Name}} value, JsonSerializerOptions options)
                              => writer.WriteStringValue(value.Value);
                      }
                  
                      // TypeConverter (for model binding, route parameters, etc.)
                      {{accessibility}} sealed class {{model.Name}}TypeConverter : TypeConverter
                      {
                          public override bool CanConvertFrom(ITypeDescriptorContext? context, Type sourceType) 
                              => sourceType == typeof(string) || base.CanConvertFrom(context, sourceType);
                          public override object? ConvertFrom(ITypeDescriptorContext? context, System.Globalization.CultureInfo? culture, object value) 
                              => value switch
                              {
                                  string s => Parse(s),
                                  _ => base.ConvertFrom(context, culture, value)
                              };
                      }
                  }
                  """;
    }
}